[{"categories":["翻译"],"content":" 原文链接：A brief overview of the TCP/IP model, SSL/TLS/HTTPS protocols and SSL certificates 在本文中，我们将了解基于SSL/TLS协议的Web加密和Web安全如何工作。我们还将了解SSL证书的结构，以及如何生成一个供自己使用的自签名证书。 我现在正在写一篇关于如何用Go（golang）创建一个安全的HTTP服务器的文章。我想没有比这更好的机会来探讨这个关于Web安全的广泛话题了。 本文，我们将广泛讨论SSL/TLS通信、HTTP协议、因特网数据包、SSL证书和其他web/因特网的基本特征。虽然它们并没有在我们日常的网络开发生活中出现，但是我们绝对应该了解它们。 ","date":"2021-10-07","objectID":"/httpswithssltls/:0:0","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"因特网是如何工作的？ 我可以用一句话回答这个问题，或者说，我们也可以在这谈论几个小时。不过我想让事情变的简单易懂。 因特网就是分布在世界各地，将不同设备互相连接起来的电网线。即使您没有看到实体的电线，但是您依旧可以想象您的智能手机通过虚拟电线连接到WiFi路由器，让您与位于您几英里之外的谷歌服务器对话。 当您想通过因特网向和您的个人设备连接的设备发送一些数据时，您需要遵守一些规则。所有在因特网上传递的数据都是由0和1组成的二进制数据。 首先，用于发送数据的应用程序需要与设备上的硬件通信，以便在因特网上发送数据。同样，设备上的硬件需要与在因特网上实际传输数据的设备（如WiFi路由器）进行通信。 当您给一个人寄信时，您会在信上标明收信人的地址，这样信就能送到正确的人手中。同样地，当您在因特网上发送一些数据时，您需要知道最终接收这些数据的设备的地址。 当一个网络应用程序在设备中启动（如Web浏览器或Web服务器）来传输或接收数据时，它将在一个端口上监听因特网数据，如8080。发送方需要知道接收方设备的端口，以便数据被正确的应用程序接收，而不是其他可能将其滥用的应用程序。 💡这些端口是由操作系统随机分配的，但是我们可以迫使操作系统将应用程序绑定到一个特定的端口上。 接收到数据的设备将无法理解它，除非它事先知道它在看什么。这个数据可能是一张图片、一首歌、一条简单的文本消息或者一个HTML文档。因此我们需要告诉接收者数据的类型，以便它可以正确理解数据。 这四个步骤描述了在因特网上进行数据传输的通信模型。其中每一步都由一个协议定义。根据协议的类型，每一步都会对数据进行相应的格式化，这样接收方就能够正确地提取数据了。 💡根据数据传输的用例，在一个特定的模型中可能有更多的步骤。您可以阅读OSI模型。任何人都可以用这个模型在因特网或局域网（LAN）上传输数据。 如果我们仔细审视这些步骤，我们会发现它们形成了一个管道：来自一个步骤的数据被发送到另一个步骤进行下一步处理，直到它在因特网上传递。然而，层可能是描述这些步骤的最合适的词汇，我们马上就会知道为什么。 ","date":"2021-10-07","objectID":"/httpswithssltls/:1:0","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"TCP/IP通信模型 传输控制协议（Transmission Control Protocol， TCP）是我们前面看到的通信模型中的传输层协议，而因特网协议（Internet Protocol，IP）是网络层协议。 这些协议共同推动了大部分的因特网通信。此时此刻，您的浏览器正在使用 TCP/IP 模型从服务器加载此网页。因此，这些协议共同构成了因特网协议套件 （internet protocol suite），如下图所示（图源维基百科）。 在上述通信模型中（左侧），应用层从源（如内部存储或 RAM）获取数据并用特定协议（如HTTP）的一些标头将其包装。这会创建一个 HTTP 协议的数据包，并且可以被像 Web 浏览器一样理解它的应用程序读取。 这个HTTP包将会被发送到传输层。传输层使用 TCP 协议标头以及源端口和目标端口包装数据包。源端口是传输数据的应用程序的端口（如 Web 浏览器），目标端口是运行在接收端的应用程序接收数据的端口。 TCP 包被网络层接收，它用源和目标 IP 地址以及 IP 协议标头将其包装。源IP地址是发送方设备的IP地址，目标地址是接收方设备的IP地址。 💡IP 地址是分配给因特网上设备的唯一编号。您可以阅读有关 IPV4 和 IPV6 IP 地址格式获得更多信息。设备的 IP 地址可以在数据传输之前就知道，也可以使用 HTTP 标头中包含的域名从DNS服务器解析。 一旦数据包被印上IP协议，它就成为了可以通过因特网传输的网络包。这是虚拟层的最后一步（（指）由计算机程序处理（的步骤））。 最后的链路层是设备上的物理层。这是硬件部分，例如设备上的网卡（NIC），它接收数据包并将源和目标MAC地址添加到数据包中。 💡媒体访问控制 （MAC） 地址是设备制造商提供的硬件部分的独特地址。使用 MAC 地址，两个设备之间的通信成为了可能 一旦数据包被源和目标的MAC地址以及一些数据传输层的标头（例如以太网：Ethernet）标记，它就可以被发送到因特网通信设备，如WiFI路由器或者卫星天线 。它们将负责数据包在因特网上的传输。 一旦数据包被接收方（上图的右侧）收到，它将被像洋葱一样去皮，直到原始数据（HTML 文档）被恢复。 一次一层（地提取数据），通过查看该层的协议，数据可以在没有任何误解的情况下被成功提取。原始数据提取后，可被正确的应用程序使用。 例如，如果服务器使用HTTP协议发送一个HTML页面，Web浏览器完全能够理解 HTTP协议的数据包并从中提取 出HTML 页面。然后，浏览器将在屏幕上呈现这个HTML文档。 💡HTTP协议还可用于传输 HTML页面以外的数据。HTTP协议的Content-Type标头可以被浏览器用来理解内容的MIME 类型 ","date":"2021-10-07","objectID":"/httpswithssltls/:2:0","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"HTTP协议 HTTP协议基于TCP/IP或者UDP/IP协议。在将任何数据发送到接收方之前，应该开启发送方和接收方之间的通信通道。这是仅使用 TCP/IP 完成的，没有任何应用层参与，如下图（图源维基百科）所示以及TCP三次握手（图源维基百科）。 首先，客户端发送一个空的数据包（（此处“空”是指）没有任何应用数据），其中TCP协议的SYN（synchronize）标志被置为1。当这个数据包被接收方收到后，它知道客户端尝试建立一个连接（会话）。 💡应用数据是指包含在应用层中的数据。 服务端会返回一个将SYN和ACK（acknowledge）标记置为1的空数据包。当客户端收到这个数据包时，它知道服务端作出了回应并且愿意接受请求。 然后客户端又会发送一个将ACK标记置为1的空数据包。一旦服务端收到这个数据包，一个TCP通信通道就开启了。 上述过程被称作TCP三次握手。一旦握手完成，一个TCP通信通道就被开启了，客户端或者服务端可以在这个连接上发送并接收应用数据，直到其中一方关闭连接。 让我们使用 Wireshark看看真实的握手过程。我将会在浏览器中打开http://info.cern.ch（世界上第一个网站），Wireshark将会为我捕获所有网络数据包。 正如您在上面截图中看到的那样，当我们想向info.cern.ch服务器发送HTTP GET请求时，首先发生的是TCP三次握手。 💡有很多很棒的东西是您无法在一个屏幕截图中看到的。我建议您在您的系统上安装Wireshark并尝试一下。您可以根据这篇精彩的演讲使用和应用Wireshark中的过滤器来跟踪TCP/IP通信通道中的数据包。 一旦连接建立，HTTP协议数据将作为应用数据，通过网络数据包发送到服务器。此数据包含纯文本格式的HTTP头。 💡然而，数据是使用二进制编码的。 一旦服务器接收到该数据，服务器就可以通过将数据发送回客户端来确认请求。从上面的屏幕截图可以看到，服务器使用HTTP协议应用数据进行响应，该数据包含响应头和纯文本的HTML文档。 一旦服务器发送回所有数据（可能是一个数据包或多个数据包），客户机必须通过发送空数据包来确认接收，空数据包的ACK标志设置为1，以及确认收到的数据包的序列号。 💡您可以通过这个视频更好地了解序列号和确认号（ACK）的用途。 一旦服务器没有更多的数据发送，它将发送一个FIN（finished）标志设置为1的空数据包，这个标记暗含了结束信息。客户端可以确认数据包并关闭连接，如下图所示（图源维基百科）。 💡在HTTP持久连接（keep-alive）中，相同的TCP连接将会被用于请求其他资源。这更高效，因为我们不必一次又一次地进行相同的TCP三次握手。 很多时候，客户端和服务器之间的通信并不顺畅。可能会丢失数据包，而且数据包可能以错误的顺序到达，因此需要重新传输数据包。 💡UDP协议在这方面有所不同。在UDP协议中，接收方不必发送接收确认数据包，并且数据包丢失或数据包顺序也不作任何严肃处理。您可以通过这个视频了解TCP和UDP协议之间的差异。 ","date":"2021-10-07","objectID":"/httpswithssltls/:3:0","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"安全问题 HTTP是一个不安全的协议，因为HTTP协议以纯文本格式编码。因此任何中间人都可以侦听TCP通信并读取您通过网络传输的个人数据。 这就是为什么像谷歌这样的搜索引擎在搜索结果中给不安全的网站分配较低的索引。然而，使一个网站安全并不是一件容易的事。但你还是可以使用Cloudflare这样的网站来使你的网站安全，而不必担心实施的问题。 ","date":"2021-10-07","objectID":"/httpswithssltls/:3:1","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"SSL/TLS概述 HTTPS是安全的超文本传输协议（HyperText Transfer Protocol Secure）的意思，但是这在某些方面具有误导性。HTTPS协议并不能单独对数据进行加密，事实上，它依赖于SSL或TLS协议层。 💡我打算用TLS协议来指代SSL和TLS协议，很快我们就会明白为什么SSL的名字在21世纪可能会产生误导。 HTTP协议层和TLS协议层都是应用层的一部分。TLS层的作用是使用TLS握手（在TCP握手之后）与服务器建立安全连接，并使用与服务器协商的一些加密算法对HTTP数据进行加密。 最后的加密数据就成为了服务器将要接收的网络数据包的应用数据。任何中间人都可能获得该数据，但是他们无法理解数据，因为应用数据是加密的。这就防止了中间人攻击。 当HTTP协议与TLS协议结合使用时，它被称为HTTPS协议。为了调用浏览器或程序使用TLS进行通信，我们通常在URL中使用https:// 协议前缀。 要了解TLS的工作原理，我们首先需要了解加密的工作原理和不同种类的加密算法。 加密是将一种格式的数据编码成另一种我们人类无法读取的格式的过程。为了加密一些数据，我们会使用不同的数学技巧和秘密参数。 其中一些参数是不能有意公开的。使用这些相同或相似的参数，我们可以破译被加密的数据。这种参数被统称为密钥（key）。如果密钥公开，任何有权访问的人都可以解密和读取我们的隐私数据。 ","date":"2021-10-07","objectID":"/httpswithssltls/:4:0","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"非对称加密算法 在非对称加密算法中，我们有两个用于加密和解密的密钥。公钥用于加密数据并将其提供给公众，只有私钥（保密不公开）才能破译它。 💡这种非对称加密被称为公钥加密法。 最流行的非对称加密算法是RSA（Rivest-Shamir-Adleman），因为它广泛用于网络上的密钥交换和数字签名验证。但是，现在浏览器正在采用一种更安全、更有效的Diffie-Hellman密钥交换算法进行密钥交换。 💡RSA私钥也可用于加密数据，公钥可以解密由私钥加密的数据。这用于生成和验证加密数据的数字签名和SSL证书（稍后解释）。 非对称加密算法通常比较慢，而且是CPU密集型（为什么），密钥或数据的长度越长，加密或解密数据的时间就越长。 因此，公钥加密法不用于批量数据加密。相反，我们使用对称加密算法来加密或解密大批量的数据，这更快，更高效。而非对称加密仅仅是传输共享对称加密密钥的方法。 ","date":"2021-10-07","objectID":"/httpswithssltls/:4:1","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"对称加密算法 对称加密算法使用相同的密钥加密和解密数据，这种密钥被称作共享密钥。这也是一种安全的算法，但是您不能将密钥公开。 对称密钥加密通常比公钥加密更快（为什么？），可用于批量数据加密。因此它也被称为块密码（ block cipher）。 对称加密算法主要用于在两个受信任方之间开启一个加密通道。只有通信双方才知道他们之间共享的数据，因为网络上没有其他人能够获得共享的对称密钥。 网络上最流行的对称加密算法之一是AES（Advanced Encryption Standard）。 ","date":"2021-10-07","objectID":"/httpswithssltls/:4:2","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"SSL（安全套接字层secure sockets layer）协议 SSL协议最早由网景（Netscape）浏览器团队设计，SSL2.0于1995年公开发布。它很快被带有安全改进的SSL 3.0所取代，但在2015年被IETF废弃。 目前，SSL协议已被没落（某些变体除外），没有人使用它。 IETF于1999年推出了TLS协议的第一个版本，该协议现在是网络上所有加密通信的标准。 💡*当有人谈及SSL时，其实他们可能是在说TLS。甚至SSL证书事实上也是TLS证书。SSL v3.1或SSL v4只是**TLS1.0+*版本的别名。 ","date":"2021-10-07","objectID":"/httpswithssltls/:4:3","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"TLS（传输层安全transport layer security）协议 TLS是对 SSL协议的改进。TLS1.0于1999年推出，经历了一些迭代。当前最受支持的TLS版本是TLS1.2。 TLS1.3于2018年推出，是对TLS1.2的一次重大革新，提高了效率和数据安全性，减少了建立安全TCP连接的握手请求次数。 TLS1.3仅支持Diffie-Hellman公钥加密算法的修改版本，用于在客户端和服务器之间共享对称密钥。它还放弃了对用于密钥交换的RSA算法的支持。 💡然而，不是所有的浏览器和服务器都支持TLS 1.3。因此，浏览器和服务器可能不兼容TLS1.3的通信，从而使用较低的TLS版本，如TLS1.2。 ","date":"2021-10-07","objectID":"/httpswithssltls/:4:4","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"使用TLS1.2的HTTPS握手 当我们发送带有https://协议前缀的HTTP请求时，首先使用我们之前看到的三次握手建立TCP连接。如下图（图源维基百科）中的蓝线所示。 💡这次TCP层的目标端口是443，这是HTTPS协议的默认端口。 TCP连接建立后，TLS握手开始。首先，客户端发送一个空数据包，但具有TLS1.2 协议层。该层包含一些元数据和一个客户端 Hello消息。 从上面的屏幕截图中可以看到，在客户端 Hello握手消息中，我们附上了我们的应用程序（如浏览器）目前支持的一些密码套件（cipher suites）列表，我们稍后再谈。 💡当发送客户端 Hello握手信息时，通信的应用程序开始可能首先尝试使用TLS协议的最高版本，如TLS 1.3，然后降级到服务器支持的合适版本。如果应用程序不支持服务器所要求的版本，它可能会放弃TCP连接并发出警告。 伴随密码套件列表，我们会发送一个 server name indication（SNI）消息，表明我们试图与之连接的主机名（域名）。服务器使用它发回与此主机名匹配的恰当的SSL证书。 当接收到客户端 Hello包后，服务端使用包含服务端 Hello消息的空包进行响应。该数据包含有服务端从客户端提供的选项列表中选择的密码套件。然后，它会发送一个数据包，其中包含我们使用 SNI 值要求的域名的 SSL 证书。此时，服务端没有其他可发的，因此它发送了带有\"服务端 Hello 完成“消息的数据包。 客户端收到SSL证书后，我们的应用程序会对其进行验证。该证书还包含一个由服务端选择的密码套件的公钥。我们将在SSL课程中讨论更多关于证书验证的过程。 密码套件包含一个加密算法列表和一个哈希函数，用于加密和验证在客户端和服务器之间传输的数据。一个有效的密码套件的简单例子如下： TLS_RSA_WITH_AES_256_CBC_SHA 如果服务端选择上述密码套件就意味着服务端将使用RSA算法对加密批量数据的共享秘钥进行加密。客户端和服务端使用的批量加密算法是AES256 bit（CBC 模式）。密码套件的最后一项是用于创建数字签名的单向散列函数。关于数字签名，我们稍后将讨论更多。 一旦客户端和服务器就密码套件达成一致，加密通信就可以开始了。到目前为止，我们所有的数据包都没有被加密，因为它们不包含任何应用数据，而且事先没有加密知识。客户端现在生成了一个用于批量数据加密的共享密钥。正如密码套件描述的那样，客户端将创建一个256位的AES对称-密钥算法的密钥，并与服务端共享。 客户端使用从 SSL 证书中获取的服务器的 RSA 公钥，对共享密钥进行加密，并与消息Client Key Exchange一起发送给服务器。该数据包还包含Change Cipher Spec消息，表示客户端正在使用商定的密码规范（agreed cipher spec）进行数据加密。 在同一个数据包中，客户端发送一个Finished握手消息，表明来自客户端的TLS握手已经完成。这个消息会被共享对称密钥（AES）加密。一旦服务端接收到这个数据包，它会使用私钥对共享对称密钥解密。由于没有其他人可以获得私钥，因此在网络上无法读取此共享密钥。 通过查看Change Cipher Spec消息，服务器也会将其数据读/写模式更改为商定的密码规范。然后它将使用刚刚得到的共享密钥解密握手消息。由于握手消息是Finished，因此它会客户端返回一个包含Change Cipher Spec的数据包，这表明服务端正在使用商定的密码规范进行数据加密，并使用共享密钥加密Finished消息。 一旦客户端收到这个数据包，TLS1.2握手就完成了，应用程序数据可以使用选定的批量数据加密算法（对称加密算法）进行加密/解密，并通过TCP通道传输。 💡中间人可以篡改握手，但是由于共享密钥已于RSA加密交换，因此握手完全安全（没理解 😕）。然而，如果被加密的Finished消息已经被篡改，TCP连接将被废弃并且无法通过同一管道进行进一步的通信。 ","date":"2021-10-07","objectID":"/httpswithssltls/:5:0","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"会话密钥（Session Keys） 有时，（客户端）原始的共享密钥不会与服务器共享，无论RSA加密有多强（预先对其进行加密）。相反，（客户端）与服务器共享预主密钥（pre-master secret）而不是共享密钥。客户端和服务器根据TLS握手期间协商的算法，使用预主密钥得到相同的共享密钥。此共享密钥将在重用之前的TLS会话（恢复）时生成，而无需经过完整的握手。但是，如果服务器的私钥被泄露，则将无法防止中间人攻击。 ","date":"2021-10-07","objectID":"/httpswithssltls/:5:1","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"使用TLS1.3的HTTPS握手 TLS1.3带来了许多改进。它放弃了对用于密钥交换的RSA加密的支持。如果服务器的私钥被泄露，任何有权访问该私钥的人都将能够解密客户端和服务器之间传输的所有消息。 ","date":"2021-10-07","objectID":"/httpswithssltls/:6:0","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"安全 TLS1.3协议被强制使用ECDHE密钥交换算法。它基本算是一种采用椭圆曲线加密技术（Elliptic-curve cryptography）的Diffie-Hellman (DH) 公钥算法。这两者一起形成了非常安全的ECDHE密码。 ECDHE的工作方式是在客户端和服务器端保留一个随机生成的私钥。客户端使用 DH算法私有参数、DH算法公共参数和椭圆曲线公共参数生成一个公钥。该公钥将与所有公共参数一起共享给服务器。服务器使用客户端的公钥和参数以及自己的DH算法私有参数，算出自己的公钥并与客户端共享。服务器根据这些结果生成共享密钥。使用服务器的公钥和之前的参数，客户端算出一个共享密钥。DH算法背后花哨的数学使得客户端和服务器可以生成相同的共享密钥。此共享密钥用于批量数据加密。 💡我不打算解释ECDHE背后的数学原理，但您可以观看这个精彩的视频来了解DH算法的工作原理。 ","date":"2021-10-07","objectID":"/httpswithssltls/:6:1","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"前向保密（Forward Secrecy） 与TLS1.2 类似，客户端和服务器端生成预主密钥（计算用于批量数据加密的最终会话密钥），而不是原始的共享密钥。 ECDHE 中的E代表临时参数。这意味着客户端和服务器使用 DH 算法生成的 DH 参数是暂时（ephemeral）的。除非重用 TLS 会话，否则每个新的TLS会话都会选择新参数并生成新的会话密钥。 由于此过程不涉及SSL私钥和公钥，所以它们对提取通过 TLS 1.3 通道传输的数据不是很有用。这使得TLS1.3通信具有完美的前向保密（PFS）。 💡如果私有参数、预主密钥或会话密钥泄露，那么攻击者也只能提取单个TLS会话的数据。 ","date":"2021-10-07","objectID":"/httpswithssltls/:6:2","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"更短的握手时间（Shorter Handshake） TLS 1.3不仅有完美的前向保密，而且可以使TLS握手非常短。 与TLS1.2一样，客户端发送客户端Hello消息，同时此数据包中还包含最终用于生成共享密钥的公共参数，如下图所示。 在同一数据包中还包含客户端支持的密码套件列表，服务器将选择使用合适的ECDHE算法。 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA 如果服务器选择上述算法，则使用RSA的ECDHE将被用于密钥交换。RSA加密仅用于数字签名（基本上使用SSL私钥加密）服务器发送的公钥（密钥交换过程），以便客户端验证它是否真的是由服务器发送的。 ","date":"2021-10-07","objectID":"/httpswithssltls/:6:3","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"未完，待续。。。 😪 ","date":"2021-10-07","objectID":"/httpswithssltls/:7:0","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["翻译"],"content":"其他可以参考的链接： HTTPS篇之SSL握手过程详解 | Razeen`s Blog ","date":"2021-10-07","objectID":"/httpswithssltls/:8:0","tags":["HTTPS","TCP/IP","计算机网络"],"title":"简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书","uri":"/httpswithssltls/"},{"categories":["编程贴士"],"content":"函数声明：int getP()与int getP(void) 总结：函数声明时参数为空是一种陋习，这表明参数类型和数目都不明确，可能会导致UB #include \u003cstdio.h\u003e int getP(); float outF(); int main(void) { printf(\"%d\\n\", getP(10)); outF(10); return 0; } int getP(int a) { int ret = 1; for (int i = 0; i \u003c a; i++) ret = ret \u003c\u003c 1; return ret; } float outF(float a) { printf(\"%f\\n\", a); } 其中一个可以过编译，而另一个不行 an argument type that has a default promotion can’t match an empty parameter name list declaration 《C语言程序设计第二版》，第4.2节： 如果函数声明中不包含参数，例如： double atof();， 那么编译程序也不会对函数 atof 的参数作任何假设，并会关闭所有的参数检查。对空参数表的这种特殊处理是为了使新的编译器能编译比较老的 C 语言程序。不过，在新编写的程序中 这么做是不提倡的。如果函数带有参数，则要声明它们；如果没有参数，则使用 void 进行声 明。 更多详情见Is it better to use C void arguments “void foo(void)” or not “void foo()”? - Stack Overflow ","date":"2021-09-28","objectID":"/emptyparameterdeclarator/:0:1","tags":["C语言"],"title":"C语言函数声明中的空参数","uri":"/emptyparameterdeclarator/"},{"categories":["算法"],"content":" 算术基本定理：任何一个大于1的自然数 N，如果N不为质数，那么N可以唯一分解成有限个质数的乘积 List\u003cInteger\u003e primeFactorization(int n) { // 分解得到的质数列表（不去重） List\u003cInteger\u003e res = new ArrayList\u003cInteger\u003e(); /* 短除法：从最小的质数开始分解 */ for (int i = 2; i * i \u003c= n; i++) { // 判断n（即模余数）是否为质数只需要遍历到sqrt(n) while (n % i == 0) { res.add(i); n /= i; } } return res; } ","date":"2021-09-20","objectID":"/primefactorization/:0:0","tags":["数学"],"title":"分解质因数","uri":"/primefactorization/"},{"categories":null,"content":"About me and this blog","date":"2020-10-28","objectID":"/about/","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" 大学四年，临近毕业发现自己上了个寂寞，学的东西很少，忘的东西很多；会的东西很少，错的东西很多。以此开设博客，记录一些值得记录的知识。希望这个博客可以督促我学习👏 (大概率不会)。 最近在做力扣每日一题，打算通过做题复习一下基础的数据结构和算法知识，顺带学习一下java(因为发现自己一门能吃饭的语言都不会😭)。 ","date":"2020-10-28","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["数据结构"],"content":"二叉树是一种重要的树形数据结构, 对其遍历的方式有以下几种: 前序 中序 后序 每一种遍历方式都有递归 与 非递归两种, 本文使用java分别进行实现。 本文阅读完成后请回答一下上图红色数字的含义及其与前、中、后序遍历的关系。 ","date":"2020-10-27","objectID":"/binarytreetraversal/:0:1","tags":["二叉树"],"title":"二叉树的遍历","uri":"/binarytreetraversal/"},{"categories":["数据结构"],"content":"二叉树的数据结构定义如下 class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } } ","date":"2020-10-27","objectID":"/binarytreetraversal/:0:2","tags":["二叉树"],"title":"二叉树的遍历","uri":"/binarytreetraversal/"},{"categories":["数据结构"],"content":"二叉树的遍历 递归 递归版本简单易懂, 注意递归顺序 前序(PreOrder) class Solution { public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003cInteger\u003e(); preOrder(root, ans); return ans; } private void preOrder(TreeNode root, List\u003cInteger\u003e ans){ if(root == null) return; ans.add(root.val); preOrder(root.left, ans); preOrder(root.right, ans); } } 中序(InOrder) class Solution { public List\u003cInteger\u003e inorderTraversal(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003cInteger\u003e(); inOrder(root, ans); return ans; } private void inOrder(TreeNode root, List\u003cInteger\u003e ans){ if(root == null) return; inOrder(root.left, ans); ans.add(root.val); inOrder(root.right, ans); } } 后序(PostOrder) class Solution { public List\u003cInteger\u003e postorderTraversal(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003cInteger\u003e(); postOrder(root, ans); return ans; } private void postOrder(TreeNode root, List\u003cInteger\u003e ans){ if(root == null) return; postOrder(root.left, ans); postOrder(root.right, ans); ans.add(root.val); } } 非递归 前序(PreOrder) 非递归即用迭代的方法模拟递归, 首先思考一下递归时的情况: 当遇到到一个节点时, 首先将其值加入列表(访问) 接下来对该节点的左子树进行递归访问 左子树访问完成后对其右子树进行递归访问 注意到在访问右子树时, 我们是从左子树访问结束回到了当前节点, 因此对已经遇到一次的节点，我们后续仍旧需要该节点的信息(访问右子树)。因此我们需要一个栈来保存已经遇到一次的节点(对应于递归时的递归栈): Deque\u003cTreeNode\u003e stack = new ArrayDeque\u003cTreeNode\u003e(); 何时需要取出栈中的节点呢? 当前子树访问结束时(即迭代走不下去了, 遇到了null) 此时我们需要取出栈顶节点(第二次遇到), 对其右子树进行迭代访问 何时整颗树的迭代结束呢? 遇到null且栈为空 这时所有节点我们都已经遇到过两次了, 已经没有未访问过的节点了 最终代码如下: class Solution { public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003cInteger\u003e(); Deque\u003cTreeNode\u003e stack = new ArrayDeque\u003cTreeNode\u003e(); TreeNode node = root; while(!stack.isEmpty() || node != null){ if(node != null){ ans.add(node.val); // 第一次遇到时访问 stack.push(node); node = node.left; } else{ node = stack.pop(); node = node.right; } } return ans; } } 中序(InOrder) 中序和前序的区别在于: 前序在第一次遇到节点时就访问, 中序则为第二次遇到节点时才访问。因而只要对前序遍历的迭代版本代码稍作改动即可得到中序遍历的迭代版本代码。 代码如下: class Solution { public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003cInteger\u003e(); Deque\u003cTreeNode\u003e stack = new ArrayDeque\u003cTreeNode\u003e(); TreeNode node = root; while(!stack.isEmpty() || node != null){ if(node != null){ stack.push(node); node = node.left; } else{ node = stack.pop(); ans.add(node.val); // 第二次遇到时访问 node = node.right; } } return ans; } } 后序(PostOrder) 类比前序和中序遍历, 后序遍历则是第三次遇到该节点时对其进行访问。但是这就出现了一个问题: 如何判断是否是第三次遇到? 在前序和中序遍历中, 第一次遇到节点时(入栈)、第二次遇到节点时(出栈), 但是在后序遍历, 第二次遇到时不能出栈, 第三次遇到才可用出栈, 所以第二次和第三次遇到节点的情况变得难以区分。 在递归方法中, 第三次遇到节点是在访问了其右子树根节点后, 因此在迭代版本中可以记录前一个访问的节点pre, 判断是否是第三次遇到节点即可转换为判断pre是否是其右子树根节点。当访问了一个新的节点时, 将pre更新为该节点。另外, 即使pre不是其右子树根节点, 若其右子树为空, 我们也可以视作第三次遇到该节点。 代码如下: class Solution { public List\u003cInteger\u003e postorderTraversal(TreeNode root) { List\u003cInteger\u003e ans = new ArrayList\u003cInteger\u003e(); if(root == null) return ans; Deque\u003cTreeNode\u003e stack = new ArrayDeque\u003cTreeNode\u003e(); TreeNode pre = null, node = root; while(!stack.isEmpty() || node != null){ if(node != null){ stack.push(node); node = node.left; } else{// 不同之处 node = stack.pop(); if(node.right == null || node.right == pre){ ans.add(node.val); pre = node; node = null; // 该节点作为根节点的子树已经访问完成 } else{ stack.push(node); node = node.right; } } } return ans; } } 注意事项： pre记录的是前一个访问的节点（区别遇到） 一定要考虑右子树为空的情况（否则会陷入无限循环：pre一直为左子树，node一直为null） ","date":"2020-10-27","objectID":"/binarytreetraversal/:0:3","tags":["二叉树"],"title":"二叉树的遍历","uri":"/binarytreetraversal/"},{"categories":["算法"],"content":"什么是快慢指针 在链表中使用两个指针，其中一个指针的移动速度比另外一个指针移动的速度快，这就是快慢指针。借助两个指针产生的距离差值，快慢指针有妙用。 ","date":"2020-10-25","objectID":"/slow_and_fast_pointer/:0:1","tags":["指针","链表"],"title":"快慢指针","uri":"/slow_and_fast_pointer/"},{"categories":["算法"],"content":"链表结构 public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } ","date":"2020-10-25","objectID":"/slow_and_fast_pointer/:0:2","tags":["指针","链表"],"title":"快慢指针","uri":"/slow_and_fast_pointer/"},{"categories":["算法"],"content":"快慢指针的妙用 找n等分点 n = 2是最常见的情况(即寻找链表的中点), 这是解决许多问题的第一步(如: No.143、No.148)。我常用的寻找2等分点代码如下(java): ListNode slow = head, fast = head; while(fast.next != tail \u0026\u0026 fast.next.next != tail){ slow = slow.next; fast = fast.next.next; } 在上述代码执行完成后, slow指针指向了链表的中间结点或中间两个结点的左结点。 判环 快慢指针的另一个重要用法就是判断链表中是否有环路(如: No.141) public class Solution { public boolean hasCycle(ListNode head) { if(head == null) return false; ListNode slow = head, fast = head.next; while(fast != null){ if(slow == fast) return true; else{ slow = slow.next; fast = fast.next; if(fast != null) fast = fast.next; } } return false; } } 进一步的, 利用快慢指针还可以找到链表开始入环的第一个节点(N0.142)。 public class Solution { public ListNode detectCycle(ListNode head) { if(head == null) return null; ListNode slow = head, fast = head; while(fast != null){ slow = slow.next; if(fast.next != null){ fast = fast.next.next; } else return null; if(slow == fast){ ListNode ptr = head; while(ptr != slow){ ptr = ptr.next; slow = slow.next; } return slow; } } return null; } } 至于为什么这样可以找到入环的第一个结点, 这里不再详述。 提醒两个关键点: fast走过的路程是slow走过路程的两倍 在slow入环的第一圈两个指针相遇 ","date":"2020-10-25","objectID":"/slow_and_fast_pointer/:0:3","tags":["指针","链表"],"title":"快慢指针","uri":"/slow_and_fast_pointer/"}]