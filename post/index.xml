<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on JayaYuan</title>
    <link>https://fenp.github.io/post/</link>
    <description>Recent content in Posts on JayaYuan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 07 Oct 2021 16:07:22 +0800</lastBuildDate><atom:link href="https://fenp.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书</title>
      <link>https://fenp.github.io/post/httpswithssltls/</link>
      <pubDate>Thu, 07 Oct 2021 16:07:22 +0800</pubDate>
      
      <guid>https://fenp.github.io/post/httpswithssltls/</guid>
      <description>原文链接：A brief overview of the TCP/IP model, SSL/TLS/HTTPS protocols and SSL certificates
在本文中，我们将了解基于SSL/TLS协议的Web加密和Web安全如何工作。我们还将了解SSL证书的结构，以及如何生成一个供自己使用的自签名证书。
我现在正在写一篇关于如何用Go（golang）创建一个安全的HTTP服务器的文章。我想没有比这更好的机会来探讨这个关于Web安全的广泛话题了。
本文，我们将广泛讨论SSL/TLS通信、HTTP协议、因特网数据包、SSL证书和其他web/因特网的基本特征。虽然它们并没有在我们日常的网络开发生活中出现，但是我们绝对应该了解它们。
 因特网是如何工作的？ 我可以用一句话回答这个问题，或者说，我们也可以在这谈论几个小时。不过我想让事情变的简单易懂。
因特网就是分布在世界各地，将不同设备互相连接起来的电网线。即使您没有看到实体的电线，但是您依旧可以想象您的智能手机通过虚拟电线连接到WiFi路由器，让您与位于您几英里之外的谷歌服务器对话。
当您想通过因特网向和您的个人设备连接的设备发送一些数据时，您需要遵守一些规则。所有在因特网上传递的数据都是由0和1组成的二进制数据。
 首先，用于发送数据的应用程序需要与设备上的硬件通信，以便在因特网上发送数据。同样，设备上的硬件需要与在因特网上实际传输数据的设备（如WiFi路由器）进行通信。 当您给一个人寄信时，您会在信上标明收信人的地址，这样信就能送到正确的人手中。同样地，当您在因特网上发送一些数据时，您需要知道最终接收这些数据的设备的地址。 当一个网络应用程序在设备中启动（如Web浏览器或Web服务器）来传输或接收数据时，它将在一个端口上监听因特网数据，如8080。发送方需要知道接收方设备的端口，以便数据被正确的应用程序接收，而不是其他可能将其滥用的应用程序。  💡这些端口是由操作系统随机分配的，但是我们可以迫使操作系统将应用程序绑定到一个特定的端口上。
接收到数据的设备将无法理解它，除非它事先知道它在看什么。这个数据可能是一张图片、一首歌、一条简单的文本消息或者一个HTML文档。因此我们需要告诉接收者数据的类型，以便它可以正确理解数据。  这四个步骤描述了在因特网上进行数据传输的通信模型。其中每一步都由一个协议定义。根据协议的类型，每一步都会对数据进行相应的格式化，这样接收方就能够正确地提取数据了。
💡根据数据传输的用例，在一个特定的模型中可能有更多的步骤。您可以阅读OSI模型。任何人都可以用这个模型在因特网或局域网（LAN）上传输数据。
如果我们仔细审视这些步骤，我们会发现它们形成了一个管道：来自一个步骤的数据被发送到另一个步骤进行下一步处理，直到它在因特网上传递。然而，层可能是描述这些步骤的最合适的词汇，我们马上就会知道为什么。
TCP/IP通信模型 传输控制协议（Transmission Control Protocol， TCP）是我们前面看到的通信模型中的传输层协议，而因特网协议（Internet Protocol，IP）是网络层协议。
这些协议共同推动了大部分的因特网通信。此时此刻，您的浏览器正在使用 TCP/IP 模型从服务器加载此网页。因此，这些协议共同构成了因特网协议套件 （internet protocol suite），如下图所示（图源维基百科）。
在上述通信模型中（左侧），应用层从源（如内部存储或 RAM）获取数据并用特定协议（如HTTP）的一些标头将其包装。这会创建一个 HTTP 协议的数据包，并且可以被像 Web 浏览器一样理解它的应用程序读取。
这个HTTP包将会被发送到传输层。传输层使用 TCP 协议标头以及源端口和目标端口包装数据包。源端口是传输数据的应用程序的端口（如 Web 浏览器），目标端口是运行在接收端的应用程序接收数据的端口。 TCP 包被网络层接收，它用源和目标 IP 地址以及 IP 协议标头将其包装。源IP地址是发送方设备的IP地址，目标地址是接收方设备的IP地址。
💡IP 地址是分配给因特网上设备的唯一编号。您可以阅读有关 IPV4 和 IPV6 IP 地址格式获得更多信息。设备的 IP 地址可以在数据传输之前就知道，也可以使用 HTTP 标头中包含的域名从DNS服务器解析。</description>
    </item>
    
    <item>
      <title>C语言函数声明中的空参数</title>
      <link>https://fenp.github.io/post/emptyparameterdeclarator/</link>
      <pubDate>Tue, 28 Sep 2021 23:01:23 +0800</pubDate>
      
      <guid>https://fenp.github.io/post/emptyparameterdeclarator/</guid>
      <description>函数声明：int getP()与int getP(void)  总结：函数声明时参数为空是一种陋习，这表明参数类型和数目都不明确，可能会导致UB
 #include &amp;lt;stdio.h&amp;gt; int getP();	float outF(); int main(void) { printf(&amp;#34;%d\n&amp;#34;, getP(10)); outF(10); return 0; } int getP(int a) { int ret = 1; for (int i = 0; i &amp;lt; a; i++) ret = ret &amp;lt;&amp;lt; 1; return ret; } float outF(float a) { printf(&amp;#34;%f\n&amp;#34;, a); } 其中一个可以过编译，而另一个不行
an argument type that has a default promotion can’t match an empty parameter name list declaration</description>
    </item>
    
    <item>
      <title>分解质因数</title>
      <link>https://fenp.github.io/post/primefactorization/</link>
      <pubDate>Mon, 20 Sep 2021 18:35:20 +0800</pubDate>
      
      <guid>https://fenp.github.io/post/primefactorization/</guid>
      <description> 算术基本定理：任何一个大于1的自然数 N，如果N不为质数，那么N可以唯一分解成有限个质数的乘积
 List&amp;lt;Integer&amp;gt; primeFactorization(int n) { // 分解得到的质数列表（不去重）  List&amp;lt;Integer&amp;gt; res = new ArrayList&amp;lt;Integer&amp;gt;(); /* 短除法：从最小的质数开始分解 */ for (int i = 2; i * i &amp;lt;= n; i++) { // 判断n（即模余数）是否为质数只需要遍历到sqrt(n)  while (n % i == 0) { res.add(i); n /= i; } } return res; } </description>
    </item>
    
    <item>
      <title>二叉树的遍历</title>
      <link>https://fenp.github.io/post/binarytreetraversal/</link>
      <pubDate>Tue, 27 Oct 2020 16:48:51 +0800</pubDate>
      
      <guid>https://fenp.github.io/post/binarytreetraversal/</guid>
      <description>二叉树是一种重要的树形数据结构, 对其遍历的方式有以下几种: 前序
中序
后序
每一种遍历方式都有递归 与 非递归两种, 本文使用java分别进行实现。
本文阅读完成后请回答一下上图红色数字的含义及其与前、中、后序遍历的关系。
  二叉树的数据结构定义如下  class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() {} TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } }  二叉树的遍历    递归 递归版本简单易懂, 注意递归顺序
   前序(PreOrder)  class Solution { public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; ans = new ArrayList&amp;lt;Integer&amp;gt;(); preOrder(root, ans); return ans; } private void preOrder(TreeNode root, List&amp;lt;Integer&amp;gt; ans){ if(root == null) return; ans.</description>
    </item>
    
    <item>
      <title>快慢指针</title>
      <link>https://fenp.github.io/post/slow_and_fast_pointer/</link>
      <pubDate>Sun, 25 Oct 2020 21:26:02 +0800</pubDate>
      
      <guid>https://fenp.github.io/post/slow_and_fast_pointer/</guid>
      <description>什么是快慢指针  在链表中使用两个指针，其中一个指针的移动速度比另外一个指针移动的速度快，这就是快慢指针。借助两个指针产生的距离差值，快慢指针有妙用。
  链表结构  public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } }  快慢指针的妙用  找n等分点  n = 2是最常见的情况(即寻找链表的中点), 这是解决许多问题的第一步(如: No.143、No.148)。我常用的寻找2等分点代码如下(java):
ListNode slow = head, fast = head; while(fast.next != tail &amp;amp;&amp;amp; fast.next.next != tail){ slow = slow.next; fast = fast.next.next; }  在上述代码执行完成后, slow指针指向了链表的中间结点或中间两个结点的左结点。</description>
    </item>
    
  </channel>
</rss>
