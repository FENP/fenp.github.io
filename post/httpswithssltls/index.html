<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="JayaYuan">
  
  
  
  <link rel="prev" href="https://fenp.github.io/post/emptyparameterdeclarator/" />
  

  
  
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-JSEGC7TY9Y"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-JSEGC7TY9Y');
  </script>
  
  
  <link rel="canonical" href="https://fenp.github.io/post/httpswithssltls/" />
  <link rel='shortcut icon' type='image/x-icon' href='/img/favicon.ico' />
  <link rel="apple-touch-icon" sizes="128x128" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">
  <link rel="manifest" href="/img/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书 | JayaYuan
       
  </title>
  <meta name="title" content="简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书 | JayaYuan">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/fenp.github.io"
    },
    "articleSection" : "post",
    "name" : "简要概述TCP\/IP模型、SSL\/TLS\/HTTPS协议以及SSL证书",
    "headline" : "简要概述TCP\/IP模型、SSL\/TLS\/HTTPS协议以及SSL证书",
    "description" : "原文链接：A brief overview of the TCP\/IP model, SSL\/TLS\/HTTPS protocols and SSL certificates\n在本文中，我们将了解基于SSL\/TLS协议的Web加密和Web安全如何工作。我们还将了解SSL证书的结构，以及如何生成一个供自己使用的自签名证书。\n我现在正在写一篇关于如何用Go（golang）创建一个安全的HTTP服务器的文章。我想没有比这更好的机会来探讨这个关于Web安全的广泛话题了。\n本文，我们将广泛讨论SSL\/TLS通信、HTTP协议、因特网数据包、SSL证书和其他web\/因特网的基本特征。虽然它们并没有在我们日常的网络开发生活中出现，但是我们绝对应该了解它们。\n 因特网是如何工作的？ 我可以用一句话回答这个问题，或者说，我们也可以在这谈论几个小时。不过我想让事情变的简单易懂。\n因特网就是分布在世界各地，将不同设备互相连接起来的电网线。即使您没有看到实体的电线，但是您依旧可以想象您的智能手机通过虚拟电线连接到WiFi路由器，让您与位于您几英里之外的谷歌服务器对话。\n当您想通过因特网向和您的个人设备连接的设备发送一些数据时，您需要遵守一些规则。所有在因特网上传递的数据都是由0和1组成的二进制数据。\n 首先，用于发送数据的应用程序需要与设备上的硬件通信，以便在因特网上发送数据。同样，设备上的硬件需要与在因特网上实际传输数据的设备（如WiFi路由器）进行通信。 当您给一个人寄信时，您会在信上标明收信人的地址，这样信就能送到正确的人手中。同样地，当您在因特网上发送一些数据时，您需要知道最终接收这些数据的设备的地址。 当一个网络应用程序在设备中启动（如Web浏览器或Web服务器）来传输或接收数据时，它将在一个端口上监听因特网数据，如8080。发送方需要知道接收方设备的端口，以便数据被正确的应用程序接收，而不是其他可能将其滥用的应用程序。  💡这些端口是由操作系统随机分配的，但是我们可以迫使操作系统将应用程序绑定到一个特定的端口上。\n接收到数据的设备将无法理解它，除非它事先知道它在看什么。这个数据可能是一张图片、一首歌、一条简单的文本消息或者一个HTML文档。因此我们需要告诉接收者数据的类型，以便它可以正确理解数据。  这四个步骤描述了在因特网上进行数据传输的通信模型。其中每一步都由一个协议定义。根据协议的类型，每一步都会对数据进行相应的格式化，这样接收方就能够正确地提取数据了。\n💡根据数据传输的用例，在一个特定的模型中可能有更多的步骤。您可以阅读OSI模型。任何人都可以用这个模型在因特网或局域网（LAN）上传输数据。\n如果我们仔细审视这些步骤，我们会发现它们形成了一个管道：来自一个步骤的数据被发送到另一个步骤进行下一步处理，直到它在因特网上传递。然而，层可能是描述这些步骤的最合适的词汇，我们马上就会知道为什么。\nTCP\/IP通信模型 传输控制协议（Transmission Control Protocol， TCP）是我们前面看到的通信模型中的传输层协议，而因特网协议（Internet Protocol，IP）是网络层协议。\n这些协议共同推动了大部分的因特网通信。此时此刻，您的浏览器正在使用 TCP\/IP 模型从服务器加载此网页。因此，这些协议共同构成了因特网协议套件 （internet protocol suite），如下图所示（图源维基百科）。\n在上述通信模型中（左侧），应用层从源（如内部存储或 RAM）获取数据并用特定协议（如HTTP）的一些标头将其包装。这会创建一个 HTTP 协议的数据包，并且可以被像 Web 浏览器一样理解它的应用程序读取。\n这个HTTP包将会被发送到传输层。传输层使用 TCP 协议标头以及源端口和目标端口包装数据包。源端口是传输数据的应用程序的端口（如 Web 浏览器），目标端口是运行在接收端的应用程序接收数据的端口。 TCP 包被网络层接收，它用源和目标 IP 地址以及 IP 协议标头将其包装。源IP地址是发送方设备的IP地址，目标地址是接收方设备的IP地址。\n💡IP 地址是分配给因特网上设备的唯一编号。您可以阅读有关 IPV4 和 IPV6 IP 地址格式获得更多信息。设备的 IP 地址可以在数据传输之前就知道，也可以使用 HTTP 标头中包含的域名从DNS服务器解析。",
    "inLanguage" : "en-us",
    "author" : "JayaYuan",
    "creator" : "JayaYuan",
    "publisher": "JayaYuan",
    "accountablePerson" : "JayaYuan",
    "copyrightHolder" : "JayaYuan",
    "copyrightYear" : "2021",
    "datePublished": "2021-10-07 16:07:22 \u002b0800 CST",
    "dateModified" : "2021-10-07 16:07:22 \u002b0800 CST",
    "url" : "https:\/\/fenp.github.io\/post\/httpswithssltls\/",
    "wordCount" : "168",
    "keywords" : [ "HTTPS","TCP\/IP","计算机网络", "JayaYuan"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan1"></i></a>&nbsp;<a href="https://fenp.github.io">JayaYuan</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/post/" title="">Posts</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan1"></i></a>&nbsp;
                    <a href="https://fenp.github.io">JayaYuan</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/post/" title="">Posts</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">简要概述TCP/IP模型、SSL/TLS/HTTPS协议以及SSL证书</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://fenp.github.io" rel="author">JayaYuan</a> with ♥ 
                <span class="post-time">
                on <time datetime=2021-10-07 itemprop="datePublished">October 7, 2021</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://fenp.github.io/categories/%E7%BF%BB%E8%AF%91/"> 翻译 </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        <img src="https://images.unsplash.com/photo-1562813733-b31f71025d54?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=869&amp;q=80" class="featured_image">
        
        
     
          
          
          

          
          
          

          <blockquote>
<p>原文链接：<a href="https://medium.com/jspoint/a-brief-overview-of-the-tcp-ip-model-ssl-tls-https-protocols-and-ssl-certificates-d5a6269fe29e">A brief overview of the TCP/IP model, SSL/TLS/HTTPS protocols and SSL certificates</a></p>
<p>在本文中，我们将了解基于SSL/TLS协议的Web加密和Web安全如何工作。我们还将了解SSL证书的结构，以及如何生成一个供自己使用的自签名证书。</p>
<p>我现在正在写一篇关于如何用Go（golang）创建一个安全的HTTP服务器的文章。我想没有比这更好的机会来探讨这个关于Web安全的广泛话题了。</p>
<p>本文，我们将广泛讨论SSL/TLS通信、HTTP协议、因特网数据包、SSL证书和其他web/因特网的基本特征。虽然它们并没有在我们日常的网络开发生活中出现，但是我们绝对应该了解它们。</p>
</blockquote>
<h2 id="因特网是如何工作的">因特网是如何工作的？</h2>
<p>我可以用一句话回答这个问题，或者说，我们也可以在这谈论几个小时。不过我想让事情变的简单易懂。</p>
<p>因特网就是分布在世界各地，将不同设备互相连接起来的电网线。即使您没有看到实体的电线，但是您依旧可以想象您的智能手机通过虚拟电线连接到WiFi路由器，让您与位于您几英里之外的谷歌服务器对话。</p>
<p>当您想通过因特网向和您的个人设备连接的设备发送一些<strong>数据</strong>时，您需要遵守一些规则。所有在因特网上传递的<strong>数据</strong>都是由<strong>0</strong>和<strong>1</strong>组成的<strong>二进制数据</strong>。</p>
<ol>
<li>首先，用于发送数据的应用程序需要与设备上的硬件通信，以便在因特网上发送数据。同样，设备上的硬件需要与在因特网上实际传输数据的设备（如<strong>WiFi路由器</strong>）进行通信。</li>
<li>当您给一个人寄信时，您会在信上标明收信人的地址，这样信就能送到正确的人手中。同样地，当您在因特网上发送一些数据时，您需要知道最终接收这些数据的设备的地址。</li>
<li>当一个网络应用程序在设备中启动（如<strong>Web浏览器</strong>或<strong>Web服务器</strong>）来传输或接收数据时，它将在一个<a href="https://en.wikipedia.org/wiki/Port_(computer_networking)"><strong>端口</strong></a>上监听因特网数据，如<strong>8080</strong>。发送方需要知道接收方设备的端口，以便数据被正确的应用程序接收，而不是其他可能将其滥用的应用程序。</li>
</ol>
<p>💡<em>这些端口是由操作系统随机分配的，但是我们可以迫使操作系统将应用程序绑定到一个特定的端口上。</em></p>
<ol start="4">
<li>接收到数据的设备将无法理解它，除非它事先知道它在看什么。这个数据可能是一张图片、一首歌、一条简单的文本消息或者一个HTML文档。因此我们需要告诉接收者数据的类型，以便它可以正确理解数据。</li>
</ol>
<p>这四个步骤描述了在因特网上进行<strong>数据传输</strong>的<strong>通信模型</strong>。其中每一步都由一个<strong>协议</strong>定义。根据协议的类型，每一步都会对数据进行相应的格式化，这样接收方就能够正确地提取数据了。</p>
<p>💡<em>根据数据传输的用例，在一个特定的模型中可能有更多的步骤。您可以阅读<a href="https://en.wikipedia.org/wiki/OSI_model#Layer_architecture">OSI模型</a>。任何人都可以用这个模型在因特网或局域网（LAN）上传输数据。</em></p>
<p>如果我们仔细审视这些步骤，我们会发现它们形成了一个管道：来自一个步骤的数据被发送到另一个步骤进行下一步处理，直到它在因特网上传递。然而，<strong>层</strong>可能是描述这些步骤的最合适的词汇，我们马上就会知道<strong>为什么</strong>。</p>
<h2 id="tcpip通信模型">TCP/IP通信模型</h2>
<p>传输控制协议（<strong>Transmission Control Protocol</strong>， TCP）是我们前面看到的通信模型中的<strong>传输层</strong>协议，而因特网协议（<strong>Internet Protocol</strong>，IP）是<strong>网络层</strong>协议。</p>
<p>这些协议共同推动了大部分的因特网通信。此时此刻，您的浏览器正在使用 TCP/IP 模型从服务器加载此网页。因此，这些协议共同构成了因特网协议套件 （<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite"><strong>internet protocol suite</strong></a>），如下图所示（图源<a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">维基百科</a>）。</p>
<p><img src="/images/HTTPwithSSLTLS/internet_protocol_suite1.png" alt="因特网协议套件1"></p>
<p><img src="/images/HTTPwithSSLTLS/internet_protocol_suite2.png" alt="因特网协议套件2"></p>
<p>在上述通信模型中（左侧），<strong>应用层</strong>从源（如内部存储或 RAM）获取数据并用特定协议（如<a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a>）的一些<strong>标头</strong>将其包装。这会创建一个 HTTP 协议的数据包，并且可以被像 Web 浏览器一样理解它的应用程序读取。</p>
<p>这个<strong>HTTP包</strong>将会被发送到<strong>传输层</strong>。传输层使用 <strong>TCP 协议标头</strong>以及<strong>源端口</strong>和<strong>目标端口</strong>包装数据包。源端口是传输数据的应用程序的端口（如 Web 浏览器），目标端口是运行在接收端的应用程序接收数据的端口。 <strong>TCP 包</strong>被网络层接收，它用源和目标 IP 地址以及 <strong>IP 协议标头</strong>将其包装。源IP地址是发送方设备的IP地址，目标地址是接收方设备的IP地址。</p>
<p>💡<em>IP 地址是分配给因特网上设备的唯一编号。您可以阅读有关  <a href="https://en.wikipedia.org/wiki/IPv4"><strong>IPV4</strong></a> 和  <a href="https://en.wikipedia.org/wiki/IPv6"><strong>IPV6</strong></a>  IP 地址格式获得更多信息。设备的 IP 地址可以在数据传输之前就知道，也可以使用 HTTP 标头中包含的<a href="https://en.wikipedia.org/wiki/Domain_Name_System"><strong>域名</strong></a>从<a href="https://www.youtube.com/watch?v=mpQZVYPuDGU"><strong>DNS</strong></a>服务器解析。</em></p>
<p>一旦数据包被印上IP协议，它就成为了可以通过因特网传输的<strong>网络包</strong>。这是虚拟层的最后一步（<em>（指）由计算机程序处理（的步骤）</em>）。</p>
<p>最后的<strong>链路层</strong>是设备上的<strong>物理层</strong>。这是硬件部分，例如设备上的网卡（<a href="https://en.wikipedia.org/wiki/Network_interface_controller">NIC</a>），它接收数据包并将源和目标MAC地址添加到数据包中。</p>
<p>💡<em>媒体访问控制 （<a href="https://en.wikipedia.org/wiki/MAC_address">MAC</a>） 地址是设备制造商提供的硬件部分的独特地址。使用 MAC 地址，两个设备之间的通信成为了可能</em></p>
<p>一旦数据包被源和目标的MAC地址以及一些<strong>数据传输层的标头</strong>（例如以太网：<a href="https://en.wikipedia.org/wiki/Ethernet"><em>Ethernet</em></a>）标记，它就可以被发送到因特网通信设备，如WiFI路由器或者<a href="https://en.wikipedia.org/wiki/Satellite_dish">卫星天线</a> 。它们将负责数据包在因特网上的传输。</p>
<p>一旦数据包被接收方（上图的右侧）收到，它将被像洋葱一样去皮，直到原始数据（HTML 文档）被恢复。</p>
<p>一次一层（地提取数据），通过查看该层的协议，数据可以在没有任何误解的情况下被成功提取。原始数据提取后，可被正确的应用程序使用。</p>
<p>例如，如果服务器使用HTTP协议发送一个HTML页面，Web浏览器完全能够理解 HTTP协议的数据包并从中提取 出HTML 页面。然后，浏览器将在屏幕上呈现这个HTML文档。</p>
<p>💡<em>HTTP协议还可用于传输 HTML页面以外的数据。HTTP协议的<code>Content-Type</code>标头可以被浏览器用来理解内容的<a href="https://en.wikipedia.org/wiki/MIME">MIME</a> 类型</em></p>
<h2 id="http协议">HTTP协议</h2>
<p>HTTP协议基于TCP/IP或者<a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</a>/IP协议。在将任何数据发送到接收方之前，应该开启发送方和接收方之间的通信通道。这是仅使用 TCP/IP 完成的，没有任何应用层参与，如下图（图源<a href="https://en.wikipedia.org/wiki/Handshaking#TCP_three-way_handshake">维基百科</a>）所示以及TCP三次握手（图源<a href="https://commons.wikimedia.org/wiki/File:TCP_Three-Way_Handshake.svg">维基百科</a>）。</p>
<p><img src="/images/HTTPwithSSLTLS/handshake1.gif" alt="三次握手1"></p>
<p><img src="/images/HTTPwithSSLTLS/handshake2.png" alt="三次握手2"></p>
<p>首先，客户端发送一个空的数据包（（此处“空”是指）没有任何应用数据），其中TCP协议的<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure"><code>SYN</code></a>（<em>synchronize</em>）标志被置为<code>1</code>。当这个数据包被接收方收到后，它知道客户端尝试建立一个连接（会话）。</p>
<p>💡<em>应用数据是指包含在应用层中的数据。</em></p>
<p>服务端会返回一个将<code>SYN</code>和<code>ACK</code>（<em>acknowledge</em>）标记置为<code>1</code>的空数据包。当客户端收到这个数据包时，它知道服务端作出了回应并且愿意接受请求。</p>
<p>然后客户端又会发送一个将<code>ACK</code>标记置为<code>1</code>的空数据包。一旦服务端收到这个数据包，一个TCP通信通道就开启了。</p>
<p>上述过程被称作<a href="https://en.wikipedia.org/wiki/Handshaking#TCP_three-way_handshake">TCP三次握手</a>。一旦握手完成，一个TCP通信通道就被开启了，客户端或者服务端可以在这个连接上发送并接收应用数据，直到其中一方关闭连接。</p>
<p>让我们使用 <a href="https://www.wireshark.org/"><strong>Wireshark</strong></a>看看真实的握手过程。我将会在浏览器中打开<a href="http://info.cern.ch/"><strong>http://info.cern.ch</strong></a>（世界上第一个网站），Wireshark将会为我捕获所有网络数据包。</p>
<p><img src="/images/HTTPwithSSLTLS/HTTPGETRequest.png" alt="HTTPGETRequest"></p>
<p>正如您在上面截图中看到的那样，当我们想向<code>info.cern.ch</code>服务器发送HTTP GET请求时，首先发生的是TCP三次握手。</p>
<p>💡<em>有很多很棒的东西是您无法在一个屏幕截图中看到的。我建议您在您的系统上安装Wireshark并尝试一下。您可以根据这篇精彩的<a href="https://youtu.be/0X2BVwNX4ks?list=PLejHxQ6h_36UrBhQmbN5wSH8xgjDMhhhA&amp;t=2158">演讲</a>使用和应用Wireshark中的过滤器来跟踪TCP/IP通信通道中的数据包。</em></p>
<p>一旦连接建立，HTTP协议数据将作为应用数据，通过网络数据包发送到服务器。此数据包含纯文本格式的HTTP头。</p>
<p>💡<em>然而，数据是使用二进制编码的。</em></p>
<p><img src="/images/HTTPwithSSLTLS/HTTP_protocol.png" alt="HTTP protocol"></p>
<p>一旦服务器接收到该数据，服务器就可以通过将数据发送回客户端来确认请求。从上面的屏幕截图可以看到，服务器使用HTTP协议应用数据进行响应，该数据包含<strong>响应头</strong>和纯文本的<strong>HTML文档</strong>。</p>
<p>一旦服务器发送回所有数据（可能是一个数据包或多个数据包），客户机必须通过发送空数据包来确认接收，空数据包的<code>ACK</code>标志设置为<code>1</code>，以及确认收到的数据包的<strong>序列号</strong>。</p>
<p>💡<em>您可以通过这个<a href="https://www.youtube.com/watch?v=BWILgDt6jz0">视频</a>更好地了解序列号和确认号（ACK）的用途。</em></p>
<p>一旦服务器没有更多的数据发送，它将发送一个<code>FIN</code>（finished）标志设置为<code>1</code>的空数据包，这个标记暗含了结束信息。客户端可以确认数据包并关闭连接，如下图所示（图源<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">维基百科</a>）。</p>
<p><img src="/images/HTTPwithSSLTLS/wavehand.png" alt="wavehand"></p>
<p>💡<em>在<a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP持久连接</a>（keep-alive）中，相同的TCP连接将会被用于请求其他资源。这更高效，因为我们不必一次又一次地进行相同的TCP三次握手。</em></p>
<p>很多时候，客户端和服务器之间的通信并不顺畅。可能会丢失数据包，而且数据包可能以错误的顺序到达，因此需要重新传输数据包。</p>
<p>💡<em>UDP协议在这方面有所不同。在UDP协议中，接收方不必发送接收确认数据包，并且数据包丢失或数据包顺序也不作任何严肃处理。您可以通过<a href="https://www.youtube.com/watch?v=Vdc8TCESIg8">这个视频</a>了解TCP和UDP协议之间的差异。</em></p>
<h3 id="安全问题">安全问题</h3>
<p>HTTP是一个不安全的协议，因为HTTP协议以纯文本格式编码。因此任何中间人都可以侦听TCP通信并读取您通过网络传输的个人数据。</p>
<p>这就是为什么像谷歌这样的搜索引擎在搜索结果中给不安全的网站分配较低的索引。然而，使一个网站安全并不是一件容易的事。但你还是可以使用<a href="https://www.cloudflare.com/">Cloudflare</a>这样的网站来使你的网站安全，而不必担心实施的问题。</p>
<h2 id="ssltls概述">SSL/TLS概述</h2>
<p>HTTPS是安全的超文本传输协议（<strong>HyperText Transfer Protocol Secure</strong>）的意思，但是这在某些方面具有误导性。HTTPS协议并不能单独对数据进行加密，事实上，它依赖于<strong>SSL</strong>或<strong>TLS</strong>协议层。</p>
<p>💡<em>我打算用TLS协议来指代SSL和TLS协议，很快我们就会明白为什么SSL的名字在21世纪可能会产生误导。</em></p>
<p>HTTP协议层和TLS协议层都是应用层的一部分。TLS层的作用是使用TLS握手（在TCP握手之后）与服务器建立安全连接，并使用与服务器协商的一些加密算法对HTTP数据进行加密。</p>
<p>最后的加密数据就成为了服务器将要接收的网络数据包的应用数据。任何中间人都可能获得该数据，但是他们无法理解数据，因为应用数据是加密的。这就防止了<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a>。</p>
<p>当HTTP协议与TLS协议结合使用时，它被称为HTTPS协议。为了调用浏览器或程序使用TLS进行通信，我们通常在URL中使用<code>https:// </code>协议前缀。</p>
<p>要了解TLS的工作原理，我们首先需要了解加密的工作原理和不同种类的加密算法。</p>
<p><a href="https://en.wikipedia.org/wiki/Encryption">加密</a>是将一种格式的数据编码成另一种我们人类无法读取的格式的过程。为了加密一些数据，我们会使用不同的数学技巧和秘密参数。</p>
<p>其中一些参数是不能有意公开的。使用这些相同或相似的参数，我们可以破译被加密的数据。这种参数被统称为密钥（<strong>key</strong>）。如果密钥公开，任何有权访问的人都可以解密和读取我们的隐私数据。</p>
<h3 id="非对称加密算法">非对称加密算法</h3>
<p>在非对称加密算法中，我们有两个用于加密和解密的密钥。<strong>公钥</strong>用于加密数据并将其提供给公众，只有<strong>私钥</strong>（保密不公开）才能破译它。</p>
<p>💡<em>这种非对称加密被称为<a href="https://en.wikipedia.org/wiki/Public-key_cryptography">公钥加密法</a>。</em></p>
<p>最流行的非对称加密算法是<a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a>（Rivest-Shamir-Adleman），因为它广泛用于网络上的密钥交换和数字签名验证。但是，现在浏览器正在采用一种更安全、更有效的<a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Diffie-Hellman</a>密钥交换算法进行密钥交换。</p>
<p>💡<em>RSA私钥也可用于加密数据，公钥可以解密由私钥加密的数据。这用于生成和验证加密数据的数字签名和SSL证书（稍后解释）。</em></p>
<p>非对称加密算法通常比较慢，而且是CPU密集型（<a href="https://crypto.stackexchange.com/questions/5782/why-is-asymmetric-cryptography-bad-for-huge-data">为什么</a>），密钥或数据的长度越长，加密或解密数据的时间就越长。</p>
<p>因此，公钥加密法不用于批量数据加密。相反，我们使用对称加密算法来加密或解密大批量的数据，这更快，更高效。而非对称加密仅仅是传输共享对称加密密钥的方法。</p>
<h3 id="对称加密算法">对称加密算法</h3>
<p><a href="https://en.wikipedia.org/wiki/Symmetric-key_algorithm">对称加密算法</a>使用<strong>相同的密钥</strong>加密和解密数据，这种密钥被称作共享密钥。这也是一种安全的算法，但是您不能将密钥公开。</p>
<p>对称密钥加密通常比公钥加密更快（<a href="https://www.quora.com/What-are-the-reasons-why-symmetric-encryption-works-fast">为什么？</a>），可用于批量数据加密。因此它也被称为<strong>块密码</strong>（ <a href="https://en.wikipedia.org/wiki/Block_cipher"><strong>block cipher</strong></a>）。</p>
<p>对称加密算法主要用于在两个受信任方之间开启一个加密通道。只有通信双方才知道他们之间共享的数据，因为网络上没有其他人能够获得共享的对称密钥。</p>
<p>网络上最流行的对称加密算法之一是<a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard.">AES</a>（<em>Advanced Encryption Standard</em>）。</p>
<h3 id="ssl安全套接字层secure-sockets-layer协议">SSL（安全套接字层<em>secure sockets layer</em>）协议</h3>
<p>SSL协议最早由网景（<a href="https://en.wikipedia.org/wiki/Netscape"><strong>Netscape</strong></a>）浏览器团队设计，SSL2.0于1995年公开发布。它很快被带有安全改进的SSL 3.0所取代，但在2015年被IETF<a href="https://tools.ietf.org/html/rfc7568">废弃</a>。</p>
<p>目前，SSL协议已被没落（某些变体除外），没有人使用它。 IETF于1999年推出了<a href="https://tools.ietf.org/html/rfc2246">TLS协议的第一个版本</a>，该协议现在是网络上所有加密通信的标准。</p>
<p>💡*当有人谈及SSL时，其实他们可能是在说TLS。甚至SSL证书事实上也是TLS证书。<strong>SSL v3.1</strong>或<strong>SSL v4</strong>只是**TLS1.0+*<em>版本的别名。</em></p>
<h3 id="tls传输层安全transport-layer-security协议">TLS（传输层安全<em>transport layer security</em>）协议</h3>
<p>TLS是对 SSL协议的改进。TLS1.0于1999年推出，经历了一些迭代。当前最受支持的TLS版本是<a href="https://tools.ietf.org/html/rfc5246">TLS1.2</a>。</p>
<p><a href="https://tools.ietf.org/html/rfc8446">TLS1.3</a>于2018年推出，是对TLS1.2的一次重大革新，提高了效率和数据安全性，减少了建立安全TCP连接的握手请求次数。</p>
<p>TLS1.3仅支持Diffie-Hellman公钥加密算法的修改版本，用于在客户端和服务器之间共享对称密钥。它还放弃了对用于密钥交换的RSA算法的支持。</p>
<p>💡<em>然而，不是所有的浏览器和服务器都支持TLS 1.3。因此，浏览器和服务器可能不兼容TLS1.3的通信，从而使用较低的TLS版本，如TLS1.2。</em></p>
<h2 id="使用tls12的https握手">使用TLS1.2的HTTPS握手</h2>
<p>当我们发送带有<code>https://</code>协议前缀的HTTP请求时，首先使用我们之前看到的三次握手建立TCP连接。如下图（图源<a href="https://commons.wikimedia.org/wiki/File:Full_TLS_1.2_Handshake.svg">维基百科</a>）中的蓝线所示。</p>
<p><img src="/images/HTTPwithSSLTLS/TLS1.2handshake.png" alt="TLS1.2handshake"></p>
<p>💡<em>这次TCP层的目标端口是<strong>443</strong>，这是HTTPS协议的<a href="https://tools.ietf.org/html/rfc2818">默认端口</a>。</em></p>
<p>TCP连接建立后，TLS握手开始。首先，客户端发送一个空数据包，但具有TLS1.2 协议层。该层包含一些元数据和一个<strong>Client Hello</strong>消息。</p>
<p><img src="/images/HTTPwithSSLTLS/TLSClientHelloMessage.png" alt="TLSClientHelloMessage"></p>
<h2 id="未完待续">未完，待续。。。</h2>
<p>😪</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>JayaYuan </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://fenp.github.io/post/httpswithssltls/>https://fenp.github.io/post/httpswithssltls/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://fenp.github.io/tags/https/">
                    #HTTPS</a></span>
            
            <span class="tag"><a href="https://fenp.github.io/tags/tcp/ip/">
                    #TCP/IP</a></span>
            
            <span class="tag"><a href="https://fenp.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                    #计算机网络</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://fenp.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://fenp.github.io/post/emptyparameterdeclarator/" class="prev" rel="prev" title="C语言函数声明中的空参数"><i class="iconfont icon-left"></i>&nbsp;C语言函数声明中的空参数</a>
         
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2020 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://fenp.github.io">JayaYuan</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
